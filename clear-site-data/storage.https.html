<!DOCTYPE html>
<html>
  <head>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/service-workers/service-worker/resources/test-helpers.sub.js"></script>
    <script src="support/test_utils.sub.js"></script>
  </head>

  <body>
    <script>
      /** @property{Datatype} The storage datatype. */
      var storage = TestUtils.DATATYPES.filter(function(datatype) {
        return datatype.name == "storage";
      })[0];

      var serviceWorkerTestPageIFrame;

      // The tests are set up asynchronously.
      setup({"explicit_done": true});

      // There must be at least one test added synchronously, otherwise
      // testharness will complain.
      // TODO(@msramek): Find a way to avoid this dummy test.
      test(function() {}, "Populate backends.");

      TestUtils.populateStorage()
          .then(() => {
            return new Promise((resolve) => {
              promise_test(function(t) {
                return navigator.serviceWorker.getRegistration("support/").then(function(reg) {
                  return wait_for_state(t, reg.active || reg.waiting || reg.installing, 'activated')
                    .then(() => {
                      resolve();
                    });
                });
              });
            });
          })
          .then(() => {
            const serviceWorkerResponseOk = TestUtils.getServiceWorkerResponseOk();

            // Create iFrame in the service worker's scope. This page will make a request
            // for another page that is only served by the service worker
            serviceWorkerTestPageIFrame = document.createElement("iframe");
            serviceWorkerTestPageIFrame.src = "support/page_using_service_worker.html";
            document.body.appendChild(serviceWorkerTestPageIFrame);

            promise_test(function() {
              return serviceWorkerResponseOk.then(function(responseIsOk) {
                assert_true(responseIsOk, "Response should be 200");
              });
            }, "Baseline: Service worker responds to request");

            return serviceWorkerResponseOk;
          })
          .then(function() {
            // Navigate to a resource with a Clear-Site-Data header in
            // an iframe, then verify that all backends of the "storage"
            // datatype have been deleted.
            return new Promise(function(resolve, reject) {
              window.addEventListener("message", resolve);
              var iframe = document.createElement("iframe");
              iframe.src = TestUtils.getClearSiteDataUrl([storage]);
              document.body.appendChild(iframe);
            }).then(function() {
              TestUtils.STORAGE.forEach(function(backend) {
                var test_name =
                    "Clear backend when 'storage' is deleted: " + backend.name;

                promise_test(function() {
                  return backend.isEmpty().then(function(isEmpty) {
                    assert_true(
                      isEmpty,
                      backend.name + " should have been cleared.");
                  });
                }, test_name);
              });

              promise_test(function() {
                const serviceWorkerResponseOk = TestUtils.getServiceWorkerResponseOk();

                // Tell the iframe to make a request for the URL that the service worker
                // responds to
                serviceWorkerTestPageIFrame.contentWindow.postMessage(null, "*");

                return serviceWorkerResponseOk.then(function(responseIsOk) {
                  assert_false(responseIsOk, "Response should not be 200");
                });
              }, "Service worker no longer responds to requests");

              done();
            });
          });
    </script>
  </body>
</html>
